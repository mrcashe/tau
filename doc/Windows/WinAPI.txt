ReadDirectoryChangesW function (winbase.h)
---------------------

Retrieves information that describes the changes within the specified directory.
The function does not report changes to the specified directory itself.

To track changes on a volume, see change journals.
Syntax
C++

BOOL ReadDirectoryChangesW(
  [in]                HANDLE                          hDirectory,
  [out]               LPVOID                          lpBuffer,
  [in]                DWORD                           nBufferLength,
  [in]                BOOL                            bWatchSubtree,
  [in]                DWORD                           dwNotifyFilter,
  [out, optional]     LPDWORD                         lpBytesReturned,
  [in, out, optional] LPOVERLAPPED                    lpOverlapped,
  [in, optional]      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
);

Parameters

[in] hDirectory

A handle to the directory to be monitored. This directory must be opened with the
FILE_LIST_DIRECTORY access right, or an access right such as GENERIC_READ that
includes the FILE_LIST_DIRECTORY access right.

[out] lpBuffer

A pointer to the DWORD-aligned formatted buffer in which the read results are to be returned.
The structure of this buffer is defined by the FILE_NOTIFY_INFORMATION structure.
This buffer is filled either synchronously or asynchronously, depending on how the directory
is opened and what value is given to the lpOverlapped parameter. For more information,
see the Remarks section.

[in] nBufferLength

The size of the buffer that is pointed to by the lpBuffer parameter, in bytes.

[in] bWatchSubtree

If this parameter is TRUE, the function monitors the directory tree rooted at the specified directory.
If this parameter is FALSE, the function monitors only the directory specified by the hDirectory parameter.

[in] dwNotifyFilter

The filter criteria that the function checks to determine if the wait operation has completed.
This parameter can be one or more of the following values.
Value 	Meaning

FILE_NOTIFY_CHANGE_FILE_NAME
0x00000001

	Any file name change in the watched directory or subtree causes a change notification
	wait operation to return. Changes include renaming, creating, or deleting a file.

FILE_NOTIFY_CHANGE_DIR_NAME
0x00000002

	Any directory-name change in the watched directory or subtree causes a change notification
	wait operation to return. Changes include creating or deleting a directory.

FILE_NOTIFY_CHANGE_ATTRIBUTES
0x00000004

	Any attribute change in the watched directory or subtree causes a change notification wait
	operation to return.

FILE_NOTIFY_CHANGE_SIZE
0x00000008

	Any file-size change in the watched directory or subtree causes a change notification wait
	operation to return. The operating system detects a change in file size only when the file
	is written to the disk. For operating systems that use extensive caching, detection occurs
	only when the cache is sufficiently flushed.

FILE_NOTIFY_CHANGE_LAST_WRITE
0x00000010

	Any change to the last write-time of files in the watched directory or subtree causes a
	change notification wait operation to return. The operating system detects a change to
	the last write-time only when the file is written to the disk. For operating systems
	that use extensive caching, detection occurs only when the cache is sufficiently flushed.

FILE_NOTIFY_CHANGE_LAST_ACCESS
0x00000020

	Any change to the last access time of files in the watched directory or subtree causes a
	change notification wait operation to return.

FILE_NOTIFY_CHANGE_CREATION
0x00000040

	Any change to the creation time of files in the watched directory or subtree causes a change
	notification wait operation to return.

FILE_NOTIFY_CHANGE_SECURITY
0x00000100

	Any security-descriptor change in the watched directory or subtree causes a change notification
	wait operation to return.

[out, optional] lpBytesReturned

For synchronous calls, this parameter receives the number of bytes transferred into the
lpBuffer parameter. For asynchronous calls, this parameter is undefined. You must use
an asynchronous notification technique to retrieve the number of bytes transferred.

[in, out, optional] lpOverlapped

A pointer to an OVERLAPPED structure that supplies data to be used during asynchronous operation.
Otherwise, this value is NULL. The Offset and OffsetHigh members of this structure are not used.

[in, optional] lpCompletionRoutine

A pointer to a completion routine to be called when the operation has been completed or canceled
and the calling thread is in an alertable wait state. For more information about this completion
routine, see FileIOCompletionRoutine.

Return value
~~~~~~~~~~~~

If the function succeeds, the return value is nonzero. For synchronous calls, this means that
the operation succeeded. For asynchronous calls, this indicates that the operation was successfully queued.

If the function fails, the return value is zero. To get extended error information, call GetLastError.

If the network redirector or the target file system does not support this operation,
the function fails with ERROR_INVALID_FUNCTION.

Remarks
~~~~~~~

To obtain a handle to a directory, use the CreateFile function with the FILE_FLAG_BACKUP_SEMANTICS flag.

A call to ReadDirectoryChangesW can be completed synchronously or asynchronously.
To specify asynchronous completion, open the directory with CreateFile as shown above,
but additionally specify the FILE_FLAG_OVERLAPPED attribute in the dwFlagsAndAttributes
parameter. Then specify an OVERLAPPED structure when you call ReadDirectoryChangesW.

When you first call ReadDirectoryChangesW, the system allocates a buffer to store
change information. This buffer is associated with the directory handle until it
is closed and its size does not change during its lifetime. Directory changes that
occur between calls to this function are added to the buffer and then returned with
the next call. If the buffer overflows, ReadDirectoryChangesW will still return true,
but the entire contents of the buffer are discarded and the lpBytesReturned parameter
will be zero, which indicates that your buffer was too small to hold all of the
changes that occurred.

Upon successful synchronous completion, the lpBuffer parameter is a formatted buffer
and the number of bytes written to the buffer is available in lpBytesReturned.
If the number of bytes transferred is zero, the buffer was either too large for
the system to allocate or too small to provide detailed information on all the changes
that occurred in the directory or subtree. In this case, you should compute the changes
by enumerating the directory or subtree.

For asynchronous completion, you can receive notification in one of three ways:

    - Using the GetOverlappedResult function. To receive notification through GetOverlappedResult,
      do not specify a completion routine in the lpCompletionRoutine parameter.
      Be sure to set the hEvent member of the OVERLAPPED structure to a unique event.

    - Using the GetQueuedCompletionStatus function. To receive notification through
      GetQueuedCompletionStatus, do not specify a completion routine in lpCompletionRoutine.
      Associate the directory handle hDirectory with a completion port by calling the
      CreateIoCompletionPort function.

    - Using a completion routine. To receive notification through a completion routine,
      do not associate the directory with a completion port. Specify a completion routine
      in lpCompletionRoutine. This routine is called whenever the operation has been
      completed or canceled while the thread is in an alertable wait state.
      The hEvent member of the OVERLAPPED structure is not used by the system,
      so you can use it yourself.

For more information, see Synchronous and Asynchronous I/O.

ReadDirectoryChangesW fails with ERROR_INVALID_PARAMETER when the buffer length is
greater than 64 KB and the application is monitoring a directory over the network.
This is due to a packet size limitation with the underlying file sharing protocols.

ReadDirectoryChangesW fails with ERROR_NOACCESS when the buffer is not aligned on a DWORD boundary.

ReadDirectoryChangesW fails with ERROR_NOTIFY_ENUM_DIR when the system was unable
to record all the changes to the directory. In this case, you should compute the changes
by enumerating the directory or subtree.

If you opened the file using the short name, you can receive change notifications for the short name.

In Windows 8 and Windows Server 2012, this function is supported by the following technologies.

Technology 	Supported
Server Message Block (SMB) 3.0 protocol 	Yes
SMB 3.0 Transparent Failover (TFO) 	        Yes
SMB 3.0 with Scale-out File Shares (SO) 	Yes
Cluster Shared Volume File System (CsvFS) 	Yes
Resilient File System (ReFS) 	            Yes

Transacted Operations
If there is a transaction bound to the directory handle, then the notifications
follow the appropriate transaction isolation rules.

Requirements
~~~~~~~~~~~~

Minimum supported client 	Windows XP [desktop apps | UWP apps]
Minimum supported server 	Windows Server 2003 [desktop apps | UWP apps]
Target Platform 	Windows
Header 	   winbase.h (include Windows.h)
Library    Kernel32.lib
DLL 	   Kernel32.dll





CreateFileW function (fileapi.h)
--------------------------------

Creates or opens a file or I/O device. The most commonly used I/O devices are as follows:
file, file stream, directory, physical disk, volume, console buffer, tape drive,
communications resource, mailslot, and pipe. The function returns a handle that can be
used to access the file or device for various types of I/O depending on the file or device
and the flags and attributes specified.

To perform this operation as a transacted operation, which results in a handle that can be
used for transacted I/O, use the CreateFileTransacted function.

Syntax
C++

HANDLE CreateFileW(
  [in]           LPCWSTR               lpFileName,
  [in]           DWORD                 dwDesiredAccess,
  [in]           DWORD                 dwShareMode,
  [in, optional] LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  [in]           DWORD                 dwCreationDisposition,
  [in]           DWORD                 dwFlagsAndAttributes,
  [in, optional] HANDLE                hTemplateFile
);

Parameters

[in] lpFileName

The name of the file or device to be created or opened. You may use either forward slashes
(/) or backslashes (\) in this name.

In the ANSI version of this function, the name is limited to MAX_PATH characters.
To extend this limit to 32,767 wide characters, use this Unicode version of the function
and prepend "\\?\" to the path. For more information, see Naming Files, Paths, and Namespaces.

For information on special device names, see Defining an MS-DOS Device Name.

To create a file stream, specify the name of the file, a colon, and then the name of the stream.
For more information, see File Streams.
Tip Starting with Windows 10, version 1607, for the unicode version of this function
(CreateFileW), you can opt-in to remove the MAX_PATH limitation without prepending "\\?\".
See the "Maximum Path Length Limitation" section of Naming Files, Paths, and Namespaces for details.

[in] dwDesiredAccess

The requested access to the file or device, which can be summarized as read, write, both or neither zero).

The most commonly used values are GENERIC_READ, GENERIC_WRITE, or both (GENERIC_READ | GENERIC_WRITE).
For more information, see Generic Access Rights, File Security and Access Rights,
File Access Rights Constants, and ACCESS_MASK.

If this parameter is zero, the application can query certain metadata such as file, directory,
or device attributes without accessing that file or device, even if GENERIC_READ access would
have been denied.

You cannot request an access mode that conflicts with the sharing mode that is specified by the
dwShareMode parameter in an open request that already has an open handle.

For more information, see the Remarks section of this topic and Creating and Opening Files.

[in] dwShareMode

The requested sharing mode of the file or device, which can be read, write, both, delete,
all of these, or none (refer to the following table). Access requests to attributes or
extended attributes are not affected by this flag.

If this parameter is zero and CreateFile succeeds, the file or device cannot be shared and
cannot be opened again until the handle to the file or device is closed. For more information,
see the Remarks section.

You cannot request a sharing mode that conflicts with the access mode that is specified in an
existing request that has an open handle. CreateFile would fail and the GetLastError
function would return ERROR_SHARING_VIOLATION.

To enable a process to share a file or device while another process has the file or device open,
use a compatible combination of one or more of the following values. For more information about
valid combinations of this parameter with the dwDesiredAccess parameter, see Creating and Opening Files.

Note The sharing options for each open handle remain in effect until that handle is closed,
regardless of process context.

Value 	Meaning

0
0x00000000

	Prevents subsequent open operations on a file or device if they request delete, read, or write access.

FILE_SHARE_DELETE
0x00000004

	Enables subsequent open operations on a file or device to request delete access.
    Otherwise, no process can open the file or device if it requests delete access.
    If this flag is not specified, but the file or device has been opened for delete access,
    the function fails.
    Note Delete access allows both delete and rename operations.

FILE_SHARE_READ
0x00000001

	Enables subsequent open operations on a file or device to request read access.
    Otherwise, no process can open the file or device if it requests read access.
    If this flag is not specified, but the file or device has been opened for read access,
    the function fails.

FILE_SHARE_WRITE
0x00000002

	Enables subsequent open operations on a file or device to request write access.
    Otherwise, no process can open the file or device if it requests write access.
    If this flag is not specified, but the file or device has been opened for write
    access or has a file mapping with write access, the function fails.

[in, optional] lpSecurityAttributes

A pointer to a SECURITY_ATTRIBUTES structure that contains two separate but related
data members: an optional security descriptor, and a Boolean value that determines
whether the returned handle can be inherited by child processes.

This parameter can be NULL.

If this parameter is NULL, the handle returned by CreateFile cannot be inherited by
any child processes the application may create and the file or device associated with
the returned handle gets a default security descriptor.

The lpSecurityDescriptor member of the structure specifies a SECURITY_DESCRIPTOR
for a file or device. If this member is NULL, the file or device associated with
the returned handle is assigned a default security descriptor.

CreateFile ignores the lpSecurityDescriptor member when opening an existing file
or device, but continues to use the bInheritHandle member.

The bInheritHandle member of the structure specifies whether the returned handle
can be inherited.

For more information, see the Remarks section.

[in] dwCreationDisposition

An action to take on a file or device that exists or does not exist.
For devices other than files, this parameter is usually set to OPEN_EXISTING.
For more information, see the Remarks section.

This parameter must be one of the following values, which cannot be combined:
Value 	Meaning

CREATE_ALWAYS
2

	Creates a new file, always.
    If the specified file exists and is writable, the function overwrites the file,
    the function succeeds, and last-error code is set to ERROR_ALREADY_EXISTS (183).

    If the specified file does not exist and is a valid path, a new file is created,
    the function succeeds, and the last-error code is set to zero.

    For more information, see the Remarks section of this topic.

CREATE_NEW
1

	Creates a new file, only if it does not already exist.

    If the specified file exists, the function fails and the last-error code is set to
    ERROR_FILE_EXISTS (80).

    If the specified file does not exist and is a valid path to a writable location,
    a new file is created.

OPEN_ALWAYS
4

	Opens a file, always.

    If the specified file exists, the function succeeds and the last-error code is set to
    ERROR_ALREADY_EXISTS (183).

    If the specified file does not exist and is a valid path to a writable location,
    the function creates a file and the last-error code is set to zero.

OPEN_EXISTING
3

	Opens a file or device, only if it exists.

    If the specified file or device does not exist, the function fails and the last-error
    code is set to ERROR_FILE_NOT_FOUND (2).

    For more information about devices, see the Remarks section.

TRUNCATE_EXISTING
5

	Opens a file and truncates it so that its size is zero bytes, only if it exists.

    If the specified file does not exist, the function fails and the last-error code
    is set to ERROR_FILE_NOT_FOUND (2).

    The calling process must open the file with the GENERIC_WRITE bit set as part of
    the dwDesiredAccess parameter.

[in] dwFlagsAndAttributes

The file or device attributes and flags, FILE_ATTRIBUTE_NORMAL being the most common
default value for files.

This parameter can include any combination of the available file attributes (FILE_ATTRIBUTE_*).
All other file attributes override FILE_ATTRIBUTE_NORMAL.

This parameter can also contain combinations of flags (FILE_FLAG_) for control of file or
device caching behavior, access modes, and other special-purpose flags.
These combine with any FILE_ATTRIBUTE_ values.

This parameter can also contain Security Quality of Service (SQOS) information by specifying
the SECURITY_SQOS_PRESENT flag. Additional SQOS-related flags information is presented in the
table following the attributes and flags tables.

Note When CreateFile opens an existing file, it generally combines the file flags with the file
attributes of the existing file, and ignores any file attributes supplied as part of
dwFlagsAndAttributes. Special cases are detailed in Creating and Opening Files.
Some of the following file attributes and flags may only apply to files and not necessarily
all other types of devices that CreateFile can open. For additional information, see the
Remarks section of this topic and Creating and Opening Files.

For more advanced access to file attributes, see SetFileAttributes.
For a complete list of all file attributes with their values and descriptions,
see File Attribute Constants.

Attribute 	Meaning

FILE_ATTRIBUTE_ARCHIVE
32 (0x20)

	The file should be archived. Applications use this attribute to mark files for backup or removal.

FILE_ATTRIBUTE_ENCRYPTED
16384 (0x4000)

	The file or directory is encrypted. For a file, this means that all data in the file is encrypted.
	For a directory, this means that encryption is the default for newly created files
	and subdirectories. For more information, see File Encryption.

    This flag has no effect if FILE_ATTRIBUTE_SYSTEM is also specified.

    This flag is not supported on Home, Home Premium, Starter, or ARM editions of Windows.

FILE_ATTRIBUTE_HIDDEN
2 (0x2)

	The file is hidden. Do not include it in an ordinary directory listing.

FILE_ATTRIBUTE_NORMAL
128 (0x80)

	The file does not have other attributes set. This attribute is valid only if used alone.

FILE_ATTRIBUTE_OFFLINE
4096 (0x1000)

	The data of a file is not immediately available. This attribute indicates that file data
	is physically moved to offline storage. This attribute is used by Remote Storage,
	the hierarchical storage management software. Applications should not arbitrarily
	change this attribute.

FILE_ATTRIBUTE_READONLY
1 (0x1)

	The file is read only. Applications can read the file, but cannot write to or delete it.

FILE_ATTRIBUTE_SYSTEM
4 (0x4)

	The file is part of or used exclusively by an operating system.

FILE_ATTRIBUTE_TEMPORARY
256 (0x100)

	The file is being used for temporary storage.

    For more information, see the Caching Behavior section of this topic.

Flag 	Meaning

FILE_FLAG_BACKUP_SEMANTICS
0x02000000

	The file is being opened or created for a backup or restore operation.
	The system ensures that the calling process overrides file security checks
	when the process has SE_BACKUP_NAME and SE_RESTORE_NAME privileges.
	For more information, see Changing Privileges in a Token.

    You must set this flag to obtain a handle to a directory.
    A directory handle can be passed to some functions instead of a file handle.
    For more information, see the Remarks section.

FILE_FLAG_DELETE_ON_CLOSE
0x04000000

	The file is to be deleted immediately after all of its handles are closed,
	which includes the specified handle and any other open or duplicated handles.

    If there are existing open handles to a file, the call fails unless they were
    all opened with the FILE_SHARE_DELETE share mode.

    Subsequent open requests for the file fail, unless the FILE_SHARE_DELETE share mode is specified.

FILE_FLAG_NO_BUFFERING
0x20000000

	The file or device is being opened with no system caching for data reads and writes.
	This flag does not affect hard disk caching or memory mapped files.

    There are strict requirements for successfully working with files opened with
    CreateFile using the FILE_FLAG_NO_BUFFERING flag, for details see File Buffering.

FILE_FLAG_OPEN_NO_RECALL
0x00100000

	The file data is requested, but it should continue to be located in remote storage.
	It should not be transported back to local storage. This flag is for use by remote storage systems.

FILE_FLAG_OPEN_REPARSE_POINT
0x00200000

	Normal reparse point processing will not occur; CreateFile will attempt to open the reparse point.
	When a file is opened, a file handle is returned, whether or not the filter that controls
	the reparse point is operational.

    This flag cannot be used with the CREATE_ALWAYS flag.
    If the file is not a reparse point, then this flag is ignored.
    For more information, see the Remarks section.

FILE_FLAG_OVERLAPPED
0x40000000

	The file or device is being opened or created for asynchronous I/O.

    When subsequent I/O operations are completed on this handle,
    the event specified in the OVERLAPPED structure will be set to the signaled state.

    If this flag is specified, the file can be used for simultaneous read and write operations.

    If this flag is not specified, then I/O operations are serialized,
    even if the calls to the read and write functions specify an OVERLAPPED structure.

    For information about considerations when using a file handle created with this flag,
    see the Synchronous and Asynchronous I/O Handles section of this topic.

FILE_FLAG_POSIX_SEMANTICS
0x01000000

	Access will occur according to POSIX rules. This includes allowing multiple files with names,
	differing only in case, for file systems that support that naming. Use care when using this option,
	because files created with this flag may not be accessible by applications that are
	written for MS-DOS or 16-bit Windows.

FILE_FLAG_RANDOM_ACCESS
0x10000000

	Access is intended to be random. The system can use this as a hint to optimize file caching.
    This flag has no effect if the file system does not support cached I/O and FILE_FLAG_NO_BUFFERING.
    For more information, see the Caching Behavior section of this topic.

FILE_FLAG_SESSION_AWARE
0x00800000

	The file or device is being opened with session awareness.
	If this flag is not specified, then per-session devices (such as a
	device using RemoteFX USB Redirection) cannot be opened by processes running
	in session 0. This flag has no effect for callers not in session 0.
	This flag is supported only on server editions of Windows.

    Windows Server 2008 R2 and Windows Server 2008: This flag is not supported before Windows Server 2012.

FILE_FLAG_SEQUENTIAL_SCAN
0x08000000

	Access is intended to be sequential from beginning to end.
	The system can use this as a hint to optimize file caching.

    This flag should not be used if read-behind (that is, reverse scans) will be used.
    This flag has no effect if the file system does not support cached I/O and FILE_FLAG_NO_BUFFERING.
    For more information, see the Caching Behavior section of this topic.

FILE_FLAG_WRITE_THROUGH
0x80000000

	Write operations will not go through any intermediate cache, they will go directly to disk.
    For additional information, see the Caching Behavior section of this topic.
    The dwFlagsAndAttributes parameter can also specify SQOS information.
    For more information, see Impersonation Levels. When the calling application
    specifies the SECURITY_SQOS_PRESENT flag as part of dwFlagsAndAttributes,
    it can also contain one or more of the following values.

Security flag 	Meaning

SECURITY_ANONYMOUS

	Impersonates a client at the Anonymous impersonation level.

SECURITY_CONTEXT_TRACKING

	The security tracking mode is dynamic. If this flag is not specified,
	the security tracking mode is static.

SECURITY_DELEGATION

	Impersonates a client at the Delegation impersonation level.

SECURITY_EFFECTIVE_ONLY

	Only the enabled aspects of the client's security context are available to the server.
	If you do not specify this flag, all aspects of the client's security context are available.
    This allows the client to limit the groups and privileges that a server can use while
    impersonating the client.

SECURITY_IDENTIFICATION

	Impersonates a client at the Identification impersonation level.

SECURITY_IMPERSONATION

	Impersonate a client at the impersonation level. This is the default behavior if
	no other flags are specified along with the SECURITY_SQOS_PRESENT flag.

[in, optional] hTemplateFile

A valid handle to a template file with the GENERIC_READ access right.
The template file supplies file attributes and extended attributes for the file that is being created.

This parameter can be NULL.

When opening an existing file, CreateFile ignores this parameter.

When opening a new encrypted file, the file inherits the discretionary access control
list from its parent directory. For additional information, see File Encryption.

Return value
~~~~~~~~~~~~

If the function succeeds, the return value is an open handle to the specified file,
device, named pipe, or mail slot.

If the function fails, the return value is INVALID_HANDLE_VALUE. To get extended error
information, call GetLastError.

Remarks
~~~~~~~

CreateFile was originally developed specifically for file interaction but has since been
expanded and enhanced to include most other types of I/O devices and mechanisms available
to Windows developers. This section attempts to cover the varied issues developers may
experience when using CreateFile in different contexts and with different I/O types.
The text attempts to use the word file only when referring specifically to data stored
in an actual file on a file system. However, some uses of file may be referring more
generally to an I/O object that supports file-like mechanisms. This liberal use of
the term file is particularly prevalent in constant names and parameter names because
of the previously mentioned historical reasons.

When an application is finished using the object handle returned by CreateFile,
use the CloseHandle function to close the handle. This not only frees up system resources,
but can have wider influence on things like sharing the file or device and committing data
to disk. Specifics are noted within this topic as appropriate.

Windows Server 2003 and Windows XP: A sharing violation occurs if an attempt is made
to open a file or directory for deletion on a remote computer when the value of the
dwDesiredAccess parameter is the DELETE access flag (0x00010000) OR'ed with any other
access flag, and the remote file or directory has not been opened with FILE_SHARE_DELETE.
To avoid the sharing violation in this scenario, open the remote file or directory
with the DELETE access right only, or call DeleteFile without first opening the file
or directory for deletion.

Some file systems, such as the NTFS file system, support compression or encryption
for individual files and directories. On volumes that have a mounted file system with
this support, a new file inherits the compression and encryption attributes of its directory.

You cannot use CreateFile to control compression, decompression, or decryption on a
file or directory. For more information, see Creating and Opening Files, File Compression
and Decompression, and File Encryption.

Windows Server 2003 and Windows XP: For backward compatibility purposes,
CreateFile does not apply inheritance rules when you specify a security descriptor
in lpSecurityAttributes. To support inheritance, functions that later query the
security descriptor of this file may heuristically determine and report that inheritance
is in effect. For more information, see Automatic Propagation of Inheritable ACEs.

As stated previously, if the lpSecurityAttributes parameter is NULL, the handle
returned by CreateFile cannot be inherited by any child processes your application
may create. The following information regarding this parameter also applies:

    - If the bInheritHandle member variable is not FALSE, which is any nonzero value,
      then the handle can be inherited. Therefore it is critical this structure member
      be properly initialized to FALSE if you do not intend the handle to be inheritable.

    - The access control lists (ACL) in the default security descriptor for a file
      or directory are inherited from its parent directory.

    - The target file system must support security on files and directories for the
      lpSecurityDescriptor member to have an effect on them, which can be determined
      by using GetVolumeInformation.

In Windows 8 and Windows Server 2012, this function is supported by the following technologies.
Technology 	Supported
Server Message Block (SMB) 3.0 protocol 	Yes
SMB 3.0 Transparent Failover (TFO) 	See remarks
SMB 3.0 with Scale-out File Shares (SO) 	See remarks
Cluster Shared Volume File System (CsvFS) 	Yes
Resilient File System (ReFS) 	Yes

Note that CreateFile with supersede disposition will fail if performed on a file where there
is already an open alternate data stream.

Symbolic Link Behavior
If the call to this function creates a file, there is no change in behavior.
Also, consider the following information regarding FILE_FLAG_OPEN_REPARSE_POINT:

    If FILE_FLAG_OPEN_REPARSE_POINT is specified:
        If an existing file is opened and it is a symbolic link, the handle returned
        is a handle to the symbolic link.

        If TRUNCATE_EXISTING or FILE_FLAG_DELETE_ON_CLOSE are specified,
        the file affected is a symbolic link.

    If FILE_FLAG_OPEN_REPARSE_POINT is not specified:
        If an existing file is opened and it is a symbolic link, the handle returned
        is a handle to the target.

        If CREATE_ALWAYS, TRUNCATE_EXISTING, or FILE_FLAG_DELETE_ON_CLOSE are specified,
        the file affected is the target.

Caching Behavior
Several of the possible values for the dwFlagsAndAttributes parameter are used by
CreateFile to control or affect how the data associated with the handle is cached by the system. They are:

    FILE_FLAG_NO_BUFFERING
    FILE_FLAG_RANDOM_ACCESS
    FILE_FLAG_SEQUENTIAL_SCAN
    FILE_FLAG_WRITE_THROUGH
    FILE_ATTRIBUTE_TEMPORARY

If none of these flags is specified, the system uses a default general-purpose caching scheme.
Otherwise, the system caching behaves as specified for each flag.

Some of these flags should not be combined. For instance, combining FILE_FLAG_RANDOM_ACCESS
with FILE_FLAG_SEQUENTIAL_SCAN is self-defeating.

Specifying the FILE_FLAG_SEQUENTIAL_SCAN flag can increase performance for applications
that read large files using sequential access. Performance gains can be even more noticeable for applications that read large files mostly sequentially, but occasionally skip forward over small ranges of bytes. If an application moves the file pointer for random access, optimum caching performance most likely will not occur. However, correct operation is still guaranteed.

The flags FILE_FLAG_WRITE_THROUGH and FILE_FLAG_NO_BUFFERING are independent and may be combined.

If FILE_FLAG_WRITE_THROUGH is used but FILE_FLAG_NO_BUFFERING is not also specified,
so that system caching is in effect, then the data is written to the system cache but
is flushed to disk without delay.

If FILE_FLAG_WRITE_THROUGH and FILE_FLAG_NO_BUFFERING are both specified, so that system
caching is not in effect, then the data is immediately flushed to disk without going through
the Windows system cache. The operating system also requests a write-through of the hard
disk's local hardware cache to persistent media.

Note Not all hard disk hardware supports this write-through capability.

Proper use of the FILE_FLAG_NO_BUFFERING flag requires special application considerations.
For more information, see File Buffering.

A write-through request via FILE_FLAG_WRITE_THROUGH also causes NTFS to flush
any metadata changes, such as a time stamp update or a rename operation,
that result from processing the request. For this reason, the FILE_FLAG_WRITE_THROUGH
flag is often used with the FILE_FLAG_NO_BUFFERING flag as a replacement for calling
the FlushFileBuffers function after each write, which can cause unnecessary
performance penalties. Using these flags together avoids those penalties.
For general information about the caching of files and metadata, see File Caching.

When FILE_FLAG_NO_BUFFERING is combined with FILE_FLAG_OVERLAPPED, the flags give
maximum asynchronous performance, because the I/O does not rely on the synchronous
operations of the memory manager. However, some I/O operations take more time,
because data is not being held in the cache. Also, the file metadata may still
be cached (for example, when creating an empty file). To ensure that the metadata
is flushed to disk, use the FlushFileBuffers function.

Specifying the FILE_ATTRIBUTE_TEMPORARY attribute causes file systems to avoid
writing data back to mass storage if sufficient cache memory is available,
because an application deletes a temporary file after a handle is closed.
In that case, the system can entirely avoid writing the data. Although it does
not directly control data caching in the same way as the previously mentioned flags,
the FILE_ATTRIBUTE_TEMPORARY attribute does tell the system to hold as much as possible
in the system cache without writing and therefore may be of concern for certain applications.

Files

If you rename or delete a file and then restore it shortly afterward,
the system searches the cache for file information to restore.
Cached information includes its short/long name pair and creation time.

If you call CreateFile on a file that is pending deletion as a result of
a previous call to DeleteFile, the function fails. The operating system
delays file deletion until all handles to the file are closed.
GetLastError returns ERROR_ACCESS_DENIED.

The dwDesiredAccess parameter can be zero, allowing the application to query
file attributes without accessing the file if the application is running with
adequate security settings. This is useful to test for the existence of a file
without opening it for read and/or write access, or to obtain other statistics
about the file or directory. See Obtaining and Setting File Information
and GetFileInformationByHandle.

If CREATE_ALWAYS and FILE_ATTRIBUTE_NORMAL are specified, CreateFile fails
and sets the last error to ERROR_ACCESS_DENIED if the file exists and has
the FILE_ATTRIBUTE_HIDDEN or FILE_ATTRIBUTE_SYSTEM attribute. To avoid the error,
specify the same attributes as the existing file.

When an application creates a file across a network, it is better to use
GENERIC_READ | GENERIC_WRITE for dwDesiredAccess than to use GENERIC_WRITE alone.
The resulting code is faster, because the redirector can use the cache manager
and send fewer SMBs with more data. This combination also avoids an issue
where writing to a file across a network can occasionally return ERROR_ACCESS_DENIED.

For more information, see Creating and Opening Files.

Synchronous and Asynchronous I/O Handles

CreateFile provides for creating a file or device handle that is either synchronous
or asynchronous. A synchronous handle behaves such that I/O function calls using
that handle are blocked until they complete, while an asynchronous file handle makes
it possible for the system to return immediately from I/O function calls, whether
they completed the I/O operation or not. As stated previously, this synchronous
versus asynchronous behavior is determined by specifying FILE_FLAG_OVERLAPPED
within the dwFlagsAndAttributes parameter. There are several complexities and
potential pitfalls when using asynchronous I/O; for more information,
see Synchronous and Asynchronous I/O.

File Streams

On NTFS file systems, you can use CreateFile to create separate streams within a file.
For more information, see File Streams.

Directories

An application cannot create a directory by using CreateFile, therefore only the
OPEN_EXISTING value is valid for dwCreationDisposition for this use case.
To create a directory, the application must call CreateDirectory or CreateDirectoryEx.

To open a directory using CreateFile, specify the FILE_FLAG_BACKUP_SEMANTICS flag as
part of dwFlagsAndAttributes. Appropriate security checks still apply when this flag
is used without SE_BACKUP_NAME and SE_RESTORE_NAME privileges.

When using CreateFile to open a directory during defragmentation of a FAT or FAT32
file system volume, do not specify the MAXIMUM_ALLOWED access right. Access to the
directory is denied if this is done. Specify the GENERIC_READ access right instead.

For more information, see About Directory Management.

Physical Disks and Volumes

Direct access to the disk or to a volume is restricted.

Windows Server 2003 and Windows XP: Direct access to the disk or to a volume is not
restricted in this manner.

You can use the CreateFile function to open a physical disk drive or a volume,
which returns a direct access storage device (DASD) handle that can be used
with the DeviceIoControl function. This enables you to access the disk or volume
directly, for example such disk metadata as the partition table. However,
this type of access also exposes the disk drive or volume to potential data loss,
because an incorrect write to a disk using this mechanism could make its contents
inaccessible to the operating system. To ensure data integrity, be sure to become
familiar with DeviceIoControl and how other APIs behave differently with a direct
access handle as opposed to a file system handle.

The following requirements must be met for such a call to succeed:

    - The caller must have administrative privileges. For more information,
      see Running with Special Privileges.

    - The dwCreationDisposition parameter must have the OPEN_EXISTING flag.

    - When opening a volume or floppy disk, the dwShareMode parameter must
      have the FILE_SHARE_WRITE flag.

Note The dwDesiredAccess parameter can be zero, allowing the application to query
device attributes without accessing a device. This is useful for an application to
determine the size of a floppy disk drive and the formats it supports without requiring
a floppy disk in a drive, for instance. It can also be used for reading statistics
without requiring higher-level data read/write permission.

When opening a physical drive x:, the lpFileName string should be the following form:
"\\.\PhysicalDriveX". Hard disk numbers start at zero. The following table shows some
examples of physical drive strings.

String 	Meaning
"\\.\PhysicalDrive0" 	Opens the first physical drive.
"\\.\PhysicalDrive2" 	Opens the third physical drive.

To obtain the physical drive identifier for a volume, open a handle to the volume and
call the DeviceIoControl function with IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS.
This control code returns the disk number and offset for each of the volume's one or
more extents; a volume can span multiple physical disks.

For an example of opening a physical drive, see Calling DeviceIoControl.

When opening a volume or removable media drive (for example, a floppy disk drive
or flash memory thumb drive), the lpFileName string should be the following form:
"\.\X:". Do not use a trailing backslash (\), which indicates the root directory
of a drive. The following table shows some examples of drive strings.

String 	Meaning
"\\.\A:" 	Opens floppy disk drive A.
"\\.\C:" 	Opens the C: volume.
"\\.\C:\" 	Opens the file system of the C: volume.

You can also open a volume by referring to its volume name. For more information,
see Naming a Volume.

A volume contains one or more mounted file systems. Volume handles can be opened
as noncached at the discretion of the particular file system, even when the noncached
option is not specified in CreateFile. You should assume that all Microsoft file
systems open volume handles as noncached. The restrictions on noncached I/O for
files also apply to volumes.

A file system may or may not require buffer alignment even though the data is noncached.
However, if the noncached option is specified when opening a volume, buffer alignment
is enforced regardless of the file system on the volume. It is recommended on all file
systems that you open volume handles as noncached, and follow the noncached I/O restrictions.

Note To read or write to the last few sectors of the volume, you must call
DeviceIoControl and specify FSCTL_ALLOW_EXTENDED_DASD_IO. This signals the file system
driver not to perform any I/O boundary checks on partition read or write calls.
Instead, boundary checks are performed by the device driver.

Changer Device

The IOCTL_CHANGER_* control codes for DeviceIoControl accept a handle to a changer device.
To open a changer device, use a file name of the following form: "\\.\Changerx" where x
is a number that indicates which device to open, starting with zero. To open changer
device zero in an application that is written in C or C++, use the following file name:
"\\\\.\\Changer0".

Tape Drives

You can open tape drives by using a file name of the following form:
"\\.\TAPEx" where x is a number that indicates which drive to open,
starting with tape drive zero. To open tape drive zero in an application
that is written in C or C++, use the following file name: "\\\\.\\TAPE0".

For more information, see Backup.

Communications Resources

The CreateFile function can create a handle to a communications resource,
such as the serial port COM1. For communications resources,
the dwCreationDisposition parameter must be OPEN_EXISTING,
the dwShareMode parameter must be zero (exclusive access),
and the hTemplateFile parameter must be NULL. Read, write, or
read/write access can be specified, and the handle can be opened for overlapped I/O.

To specify a COM port number greater than 9, use the following syntax: "\.\COM10".
This syntax works for all port numbers and hardware that allows COM port numbers to be specified.

For more information about communications, see Communications.

Consoles

The CreateFile function can create a handle to console input (CONIN$).
If the process has an open handle to it as a result of inheritance or duplication,
it can also create a handle to the active screen buffer (CONOUT$). The calling process
must be attached to an inherited console or one allocated by the AllocConsole function.
For console handles, set the CreateFile parameters as follows.

Parameters 	Value
lpFileName 	Use the CONIN$ value to specify console input.

Use the CONOUT$ value to specify console output.

CONIN$ gets a handle to the console input buffer, even if the SetStdHandle function
redirects the standard input handle. To get the standard input handle, use the GetStdHandle function.

CONOUT$ gets a handle to the active screen buffer, even if SetStdHandle redirects
the standard output handle. To get the standard output handle, use GetStdHandle.

dwDesiredAccess 	GENERIC_READ | GENERIC_WRITE is preferred, but either one can limit access.
dwShareMode 	When opening CONIN$, specify FILE_SHARE_READ. When opening CONOUT$, specify FILE_SHARE_WRITE.

If the calling process inherits the console, or if a child process should be able to
access the console, this parameter must be FILE_SHARE_READ | FILE_SHARE_WRITE.

lpSecurityAttributes 	If you want the console to be inherited, the bInheritHandle
member of the SECURITY_ATTRIBUTES structure must be TRUE.

dwCreationDisposition 	You should specify OPEN_EXISTING when using CreateFile to open the console.
dwFlagsAndAttributes 	Ignored.
hTemplateFile 	Ignored.

The following table shows various settings of dwDesiredAccess and lpFileName.
lpFileName 	dwDesiredAccess 	Result
"CON" 	GENERIC_READ 	Opens console for input.
"CON" 	GENERIC_WRITE 	Opens console for output.
"CON" 	GENERIC_READ | GENERIC_WRITE 	Causes CreateFile to fail; GetLastError returns ERROR_FILE_NOT_FOUND.

Mailslots

If CreateFile opens the client end of a mailslot, the function returns INVALID_HANDLE_VALUE
if the mailslot client attempts to open a local mailslot before the mailslot server has
created it with the CreateMailSlot function.

For more information, see Mailslots.

Pipes

If CreateFile opens the client end of a named pipe, the function uses any instance of the named
pipe that is in the listening state. The opening process can duplicate the handle as many times
as required, but after it is opened, the named pipe instance cannot be opened by another client.
The access that is specified when a pipe is opened must be compatible with the access that
is specified in the dwOpenMode parameter of the CreateNamedPipe function.

If the CreateNamedPipe function was not successfully called on the server prior to this operation,
a pipe will not exist and CreateFile will fail with ERROR_FILE_NOT_FOUND.

If there is at least one active pipe instance but there are no available listener pipes on the server,
which means all pipe instances are currently connected, CreateFile fails with ERROR_PIPE_BUSY.

For more information, see Pipes.

Note

The fileapi.h header defines CreateFile as an alias which automatically selects the ANSI or Unicode
version of this function based on the definition of the UNICODE preprocessor constant.
Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead
to mismatches that result in compilation or runtime errors. For more information,
see Conventions for Function Prototypes.

Requirements

Minimum supported client 	Windows XP [desktop apps only]
Minimum supported server 	Windows Server 2003 [desktop apps only]
Target Platform 	Windows
Header 	fileapi.h (include Windows.h)
Library 	Kernel32.lib
DLL 	Kernel32.dll


GetFileAttributesExW function (fileapi.h)
-----------------------------------------

Retrieves attributes for a specified file or directory.

To perform this operation as a transacted operation, use the GetFileAttributesTransacted function.

Syntax
C++

BOOL GetFileAttributesExW(
  [in]  LPCWSTR                lpFileName,
  [in]  GET_FILEEX_INFO_LEVELS fInfoLevelId,
  [out] LPVOID                 lpFileInformation
);

Parameters

[in] lpFileName

The name of the file or directory.

In the ANSI version of this function, the name is limited to MAX_PATH characters.
To extend this limit to 32,767 wide characters, call the Unicode version of the
function (GetFileAttributesExW), and prepend "\\?\" to the path. For more information,
see Naming a File.

Tip  Starting in Windows 10, version 1607, for the unicode version of this function
(GetFileAttributesExW), you can opt-in to remove the MAX_PATH character limitation
without prepending "\\?\". See the "Maximum Path Limitation" section of Naming Files,
Paths, and Namespaces for details.

[in] fInfoLevelId

A class of attribute information to retrieve.

This parameter can be the following value from the GET_FILEEX_INFO_LEVELS enumeration.
Value 	Meaning

GetFileExInfoStandard

	The lpFileInformation parameter is a WIN32_FILE_ATTRIBUTE_DATA structure.

[out] lpFileInformation

A pointer to a buffer that receives the attribute information.

The type of attribute information that is stored into this buffer is determined
by the value of fInfoLevelId.

Return value
~~~~~~~~~~~~

If the function succeeds, the return value is a nonzero value.

If the function fails, the return value is zero (0). To get extended error information, call GetLastError.

Remarks
~~~~~~~

The GetFileAttributes function retrieves file system attribute information.
GetFileAttributesEx can obtain other sets of file or directory attribute information.
Currently, GetFileAttributesEx retrieves a set of standard attributes that is a superset
of the file system attribute information.

When the GetFileAttributesEx function is called on a directory that is a mounted folder,
it returns the attributes of the directory, not those of the root directory in the volume
that the mounted folder associates with the directory. To obtain the attributes of the
associated volume, call GetVolumeNameForVolumeMountPoint to obtain the name of the
associated volume. Then use the resulting name in a call to GetFileAttributesEx.
The results are the attributes of the root directory on the associated volume.

In Windows 8 and Windows Server 2012, this function is supported by the following technologies.

Technology 	Supported

Server Message Block (SMB) 3.0 protocol 	Yes
SMB 3.0 Transparent Failover (TFO) 	        Yes
SMB 3.0 with Scale-out File Shares (SO) 	Yes
Cluster Shared Volume File System (CsvFS) 	Yes
Resilient File System (ReFS) 	            Yes

Symbolic link behavior—If the path points to a symbolic link, the function returns
attributes for the symbolic link.

Transacted Operations

If a file is open for modification in a transaction, no other thread can open the
file for modification until the transaction is committed. So if a transacted thread
opens the file first, any subsequent threads that try modifying the file before the
transaction is committed receives a sharing violation. If a non-transacted thread
modifies the file before the transacted thread does, and the file is still open when
the transaction attempts to open it, the transaction receives the error ERROR_TRANSACTIONAL_CONFLICT.

Note

The fileapi.h header defines GetFileAttributesEx as an alias which automatically selects
the ANSI or Unicode version of this function based on the definition of the UNICODE
preprocessor constant. Mixing usage of the encoding-neutral alias with code that not
encoding-neutral can lead to mismatches that result in compilation or runtime errors.
For more information, see Conventions for Function Prototypes.

Requirements

Minimum supported client 	Windows XP [desktop apps | UWP apps]
Minimum supported server 	Windows Server 2003 [desktop apps | UWP apps]

Target Platform 	Windows

Header 	fileapi.h (include Windows.h)
Library 	Kernel32.lib
DLL 	Kernel32.dll



BeginPaint function (winuser.h)
-------------------------------

The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting.
Syntax

HDC BeginPaint(
    [in]  HWND          hWnd,
    [out] LPPAINTSTRUCT lpPaint
);

Parameters

[in] hWnd

Handle to the window to be repainted.

[out] lpPaint

Pointer to the PAINTSTRUCT structure that will receive painting information.
Return value

If the function succeeds, the return value is the handle to a display device context for the specified window.

If the function fails, the return value is NULL, indicating that no display device context is available.

Remarks
~~~~~~~

The BeginPaint function automatically sets the clipping region of the device context to exclude any area
outside the update region. The update region is set by the InvalidateRect or InvalidateRgn function and
by the system after sizing, moving, creating, scrolling, or any other operation that affects the client area.
If the update region is marked for erasing, BeginPaint sends a WM_ERASEBKGND message to the window.

An application should not call BeginPaint except in response to a WM_PAINT message. Each call to
BeginPaint must have a corresponding call to the EndPaint function.

If the caret is in the area to be painted, BeginPaint automatically hides the caret to prevent it from being erased.

If the window's class has a background brush, BeginPaint uses that brush to erase the background of the update region before returning.

DPI Virtualization

This API does not participate in DPI virtualization. The output returned is always in terms of physical pixels.

FormatMessage function (winbase.h)

Article
09/23/2022
11 minutes to read

Formats a message string. The function requires a message definition as input. The message definition can come from a buffer passed into the function. It can come from a message table resource in an already-loaded module. Or the caller can ask the function to search the system's message table resource(s) for the message definition. The function finds the message definition in a message table resource based on a message identifier and a language identifier. The function copies the formatted message text to an output buffer, processing any embedded insert sequences if requested.
Syntax
C++

------------------------------------------------------

DWORD FormatMessage(
    [in]           DWORD   dwFlags,
    [in, optional] LPCVOID lpSource,
    [in]           DWORD   dwMessageId,
    [in]           DWORD   dwLanguageId,
    [out]          LPTSTR  lpBuffer,
    [in]           DWORD   nSize,
    [in, optional] va_list *Arguments
);

Parameters

[in] dwFlags

The formatting options, and how to interpret the lpSource parameter.
The low-order byte of dwFlags specifies how the function handles line breaks in the output buffer.
The low-order byte can also specify the maximum width of a formatted output line.

This parameter can be one or more of the following values.
Value 	Meaning

FORMAT_MESSAGE_ALLOCATE_BUFFER
0x00000100

The function allocates a buffer large enough to hold the formatted message, and places a pointer
to the allocated buffer at the address specified by lpBuffer. The lpBuffer parameter is a pointer to an LPTSTR;
you must cast the pointer to an LPTSTR (for example, (LPTSTR)&lpBuffer). The nSize parameter specifies
the minimum number of TCHARs to allocate for an output message buffer. The caller should use the LocalFree
function to free the buffer when it is no longer needed.

If the length of the formatted message exceeds 128K bytes, then FormatMessage will fail and a subsequent
call to GetLastError will return ERROR_MORE_DATA.

In previous versions of Windows, this value was not available for use when compiling Windows Store apps.
As of Windows 10 this value can be used.

Windows Server 2003 and Windows XP:

If the length of the formatted message exceeds 128K bytes, then FormatMessage will not automatically
fail with an error of ERROR_MORE_DATA.

FORMAT_MESSAGE_ARGUMENT_ARRAY
0x00002000

The Arguments parameter is not a va_list structure, but is a pointer to an array of values that represent the arguments.

This flag cannot be used with 64-bit integer values. If you are using a 64-bit integer, you must use the va_list structure.

FORMAT_MESSAGE_FROM_HMODULE
0x00000800

The lpSource parameter is a module handle containing the message-table resource(s) to search.
If this lpSource handle is NULL, the current process's application image file will be searched.
This flag cannot be used with FORMAT_MESSAGE_FROM_STRING.

If the module has no message table resource, the function fails with ERROR_RESOURCE_TYPE_NOT_FOUND.

FORMAT_MESSAGE_FROM_STRING
0x00000400

The lpSource parameter is a pointer to a null-terminated string that contains a message definition.
The message definition may contain insert sequences, just as the message text in a message table resource may.
This flag cannot be used with FORMAT_MESSAGE_FROM_HMODULE or FORMAT_MESSAGE_FROM_SYSTEM.

FORMAT_MESSAGE_FROM_SYSTEM
0x00001000

The function should search the system message-table resource(s) for the requested message.
If this flag is specified with FORMAT_MESSAGE_FROM_HMODULE, the function searches the system message table
if the message is not found in the module specified by lpSource. This flag cannot be used with FORMAT_MESSAGE_FROM_STRING.

If this flag is specified, an application can pass the result of the GetLastError function to retrieve the
message text for a system-defined error.

FORMAT_MESSAGE_IGNORE_INSERTS
0x00000200

Insert sequences in the message definition such as %1 are to be ignored and passed through to the output buffer unchanged.
This flag is useful for fetching a message for later formatting. If this flag is set, the Arguments parameter is ignored.


The low-order byte of dwFlags can specify the maximum width of a formatted output line. The following are possible values
of the low-order byte.

Value 	Meaning

0

There are no output line width restrictions. The function stores line breaks that are in the message
definition text into the output buffer.

FORMAT_MESSAGE_MAX_WIDTH_MASK
0x000000FF

The function ignores regular line breaks in the message definition text.
The function stores hard-coded line breaks in the message definition text into the output buffer.
The function generates no new line breaks.


If the low-order byte is a nonzero value other than FORMAT_MESSAGE_MAX_WIDTH_MASK,
it specifies the maximum number of characters in an output line. The function ignores regular line
breaks in the message definition text. The function never splits a string delimited by white space
across a line break. The function stores hard-coded line breaks in the message definition text into
the output buffer. Hard-coded line breaks are coded with the %n escape sequence.

[in, optional] lpSource

The location of the message definition. The type of this parameter depends upon the settings
in the dwFlags parameter.

dwFlags Setting 	Meaning

FORMAT_MESSAGE_FROM_HMODULE
0x00000800

A handle to the module that contains the message table to search.

FORMAT_MESSAGE_FROM_STRING
0x00000400

Pointer to a string that consists of unformatted message text. It will be scanned for inserts
and formatted accordingly.


If neither of these flags is set in dwFlags, then lpSource is ignored.

[in] dwMessageId

The message identifier for the requested message. This parameter is ignored if dwFlags includes FORMAT_MESSAGE_FROM_STRING.

[in] dwLanguageId

The language identifier for the requested message. This parameter is ignored if dwFlags includes FORMAT_MESSAGE_FROM_STRING.

If you pass a specific LANGID in this parameter, FormatMessage will return a message for that LANGID only.
If the function cannot find a message for that LANGID, it sets Last-Error to ERROR_RESOURCE_LANG_NOT_FOUND.
If you pass in zero, FormatMessage looks for a message for LANGIDs in the following order:

Language neutral
Thread LANGID, based on the thread's locale value
User default LANGID, based on the user's default locale value
System default LANGID, based on the system default locale value
US English

If FormatMessage does not locate a message for any of the preceding LANGIDs, it returns any language message
string that is present. If that fails, it returns ERROR_RESOURCE_LANG_NOT_FOUND.

[out] lpBuffer

A pointer to a buffer that receives the null-terminated string that specifies the formatted message.
If dwFlags includes FORMAT_MESSAGE_ALLOCATE_BUFFER, the function allocates a buffer using the LocalAlloc
function, and places the pointer to the buffer at the address specified in lpBuffer.

This buffer cannot be larger than 64K bytes.

[in] nSize

If the FORMAT_MESSAGE_ALLOCATE_BUFFER flag is not set, this parameter specifies the size of the output buffer,
in TCHARs. If FORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter specifies the minimum number of TCHARs
to allocate for an output buffer.

The output buffer cannot be larger than 64K bytes.

[in, optional] Arguments

An array of values that are used as insert values in the formatted message.
A %1 in the format string indicates the first value in the Arguments array;
a %2 indicates the second argument; and so on.

The interpretation of each value depends on the formatting information associated with the insert
in the message definition. The default is to treat each value as a pointer to a null-terminated string.

By default, the Arguments parameter is of type va_list*, which is a language- and implementation-specific
data type for describing a variable number of arguments. The state of the va_list argument is undefined
upon return from the function. To use the va_list again, destroy the variable argument list pointer
using va_end and reinitialize it with va_start.

If you do not have a pointer of type va_list*, then specify the FORMAT_MESSAGE_ARGUMENT_ARRAY flag
and pass a pointer to an array of DWORD_PTR values; those values are input to the message formatted
as the insert values. Each insert must have a corresponding element in the array.

Return value

If the function succeeds, the return value is the number of TCHARs stored in the output buffer,
excluding the terminating null character.

If the function fails, the return value is zero. To get extended error information, call GetLastError.
Remarks

Within the message text, several escape sequences are supported for dynamically formatting the message.
These escape sequences and their meanings are shown in the following tables. All escape sequences start
with the percent character (%).

Escape sequence 	Meaning

%0 	Terminates a message text line without a trailing new line character.
This escape sequence can be used to build up long lines or to terminate the message itself
without a trailing new line character. It is useful for prompt messages.

%n!format string! 	Identifies an insert sequence. The value of n can be in the range from 1 through 99.
The format string (which must be surrounded by exclamation marks) is optional and defaults to !s!
if not specified. For more information, see Format Specification Fields.

The format string can include a width and precision specifier for strings and a width specifier for integers.
Use an asterisk () to specify the width and precision. For example, %1!.*s! or %1!*u!.

If you do not use the width and precision specifiers, the insert numbers correspond directly to the input arguments.
For example, if the source string is "%1 %2 %1" and the input arguments are "Bill" and "Bob",
the formatted output string is "Bill Bob Bill".

However, if you use a width and precision specifier, the insert numbers do not correspond directly
to the input arguments. For example, the insert numbers for the previous example could change to "%1!*.*s! %4 %5!*s!".

The insert numbers depend on whether you use an arguments array (FORMAT_MESSAGE_ARGUMENT_ARRAY)
or a va_list. For an arguments array, the next insert number is n+2 if the previous format string
contained one asterisk and is n+3 if two asterisks were specified. For a va_list, the next insert number
is n+1 if the previous format string contained one asterisk and is n+2 if two asterisks were specified.

If you want to repeat "Bill", as in the previous example, the arguments must include "Bill" twice.
For example, if the source string is "%1!*.*s! %4 %5!*s!", the arguments could be, 4, 2, Bill, Bob,
6, Bill (if using the FORMAT_MESSAGE_ARGUMENT_ARRAY flag). The formatted string would then be "  Bi Bob   Bill".

Repeating insert numbers when the source string contains width and precision specifiers
may not yield the intended results. If you replaced %5 with %1, the function would try to
print a string at address 6 (likely resulting in an access violation).

Floating-point format specifiers—e, E, f, and g—are not supported. The workaround is to use the StringCchPrintf
function to format the floating-point number into a temporary buffer, then use that buffer as the insert string.

Inserts that use the I64 prefix are treated as two 32-bit arguments. They must be used before subsequent
arguments are used. Note that it may be easier for you to use StringCchPrintf instead of this prefix.


Any other nondigit character following a percent character is formatted in the output message without the percent character.
Following are some examples.

Format string 	Resulting output

%% 	A single percent sign.
%b 	A single space. This format string can be used to ensure the appropriate number of trailing spaces in a message text line.
%. 	A single period. This format string can be used to include a single period at the beginning of a line without terminating the message text definition.
%! 	A single exclamation point. This format string can be used to include an exclamation point immediately after an insert without its being mistaken for the beginning of a format string.
%n 	A hard line break when the format string occurs at the end of a line. This format string is useful when FormatMessage is supplying regular line breaks so the message fits in a certain width.
%r 	A hard carriage return without a trailing newline character.
%t 	A single tab.

Security Remarks
If this function is called without FORMAT_MESSAGE_IGNORE_INSERTS, the Arguments parameter must contain enough parameters
to satisfy all insertion sequences in the message string, and they must be of the correct type.
Therefore, do not use untrusted or unknown message strings with inserts enabled because they can contain
more insertion sequences than Arguments provides, or those that may be of the wrong type. In particular,
it is unsafe to take an arbitrary system error code returned from an API and use FORMAT_MESSAGE_FROM_SYSTEM
without FORMAT_MESSAGE_IGNORE_INSERTS.

Examples

The FormatMessage function can be used to obtain error message strings for the system error codes returned
by GetLastError. For an example, see Retrieving the Last-Error Code.

The following example shows how to use an argument array and the width and precision specifiers.
C++

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <stdio.h>

void main(void)
{
    LPWSTR pMessage = L"%1!*.*s! %4 %5!*s!";
    DWORD_PTR pArgs[] = { (DWORD_PTR)4, (DWORD_PTR)2, (DWORD_PTR)L"Bill",  // %1!*.*s! refers back to the first insertion string in pMessage
        (DWORD_PTR)L"Bob",                                                // %4 refers back to the second insertion string in pMessage
        (DWORD_PTR)6, (DWORD_PTR)L"Bill" };                               // %5!*s! refers back to the third insertion string in pMessage
        const DWORD size = 100+1;
        WCHAR buffer[size];


        if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            pMessage,
            0,
            0,
            buffer,
            size,
            (va_list*)pArgs))
        {
            wprintf(L"Format message failed with 0x%x\n", GetLastError());
            return;
        }

        // Buffer contains "  Bi Bob   Bill".
        wprintf(L"Formatted message: %s\n", buffer);
}


The following example shows how to implement the previous example using va_list.
C++

#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <stdio.h>

LPWSTR GetFormattedMessage(LPWSTR pMessage, ...);

void main(void)
{
    LPWSTR pBuffer = NULL;
    LPWSTR pMessage = L"%1!*.*s! %3 %4!*s!";

    // The variable length arguments correspond directly to the format
    // strings in pMessage.
    pBuffer = GetFormattedMessage(pMessage, 4, 2, L"Bill", L"Bob", 6, L"Bill");
    if (pBuffer)
    {
        // Buffer contains "  Bi Bob   Bill".
        wprintf(L"Formatted message: %s\n", pBuffer);
        LocalFree(pBuffer);
    }
    else
    {
        wprintf(L"Format message failed with 0x%x\n", GetLastError());
    }
}

// Formats a message string using the specified message and variable
// list of arguments.
LPWSTR GetFormattedMessage(LPWSTR pMessage, ...)
{
    LPWSTR pBuffer = NULL;

    va_list args = NULL;
    va_start(args, pMessage);

    FormatMessage(FORMAT_MESSAGE_FROM_STRING |
    FORMAT_MESSAGE_ALLOCATE_BUFFER,
    pMessage,
    0,
    0,
    (LPWSTR)&pBuffer,
                  0,
                  &args);

    va_end(args);

    return pBuffer;
}

Requirements

Minimum supported client 	Windows XP [desktop apps | UWP apps]
Minimum supported server 	Windows Server 2003 [desktop apps | UWP apps]
Target Platform 	Windows
Header 	winbase.h (include Windows.h)
Library 	Kernel32.lib
DLL 	Kernel32.dll


Retrieving the Last-Error Code
------------------------------

Article
01/07/2021
2 minutes to read

When many system functions fail, they set the last-error code.
If your application needs more details about an error, it can retrieve the last-error
code using the GetLastError function and display a description of the error using the FormatMessage function.

The following example includes an error-handling function that prints the error message and terminates the process.
The lpszFunction parameter is the name of the function that set the last-error code.

C++

#include <windows.h>
#include <strsafe.h>

void ErrorExit(LPTSTR lpszFunction) {
    // Retrieve the system error message for the last-error code

    LPVOID lpMsgBuf;
    LPVOID lpDisplayBuf;
    DWORD dw = GetLastError();

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPTSTR) &lpMsgBuf,
                  0, NULL );

    // Display the error message and exit the process

    lpDisplayBuf = (LPVOID)LocalAlloc(LMEM_ZEROINIT,
                                      (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) * sizeof(TCHAR));
    StringCchPrintf((LPTSTR)lpDisplayBuf,
                    LocalSize(lpDisplayBuf) / sizeof(TCHAR),
                    TEXT("%s failed with error %d: %s"),
                    lpszFunction, dw, lpMsgBuf);
    MessageBox(NULL, (LPCTSTR)lpDisplayBuf, TEXT("Error"), MB_OK);

    LocalFree(lpMsgBuf);
    LocalFree(lpDisplayBuf);
    ExitProcess(dw);
}

void main() {
    // Generate an error

    if(!GetProcessId(NULL))
        ErrorExit(TEXT("GetProcessId"));
}

VERSION INFO

typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR  szCSDVersion[128];
    WORD  wServicePackMajor;
    WORD  wServicePackMinor;
    WORD  wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;

Members

dwOSVersionInfoSize

The size of this data structure, in bytes. Set this member to sizeof(OSVERSIONINFOEX).

dwMajorVersion

The major version number of the operating system. For more information, see Remarks.

dwMinorVersion

The minor version number of the operating system. For more information, see Remarks.

dwBuildNumber

The build number of the operating system.

dwPlatformId

The operating system platform. This member can be VER_PLATFORM_WIN32_NT (2).

szCSDVersion[128]

A null-terminated string, such as "Service Pack 3", that indicates the latest Service Pack installed on the system.
If no Service Pack has been installed, the string is empty.

wServicePackMajor

The major version number of the latest Service Pack installed on the system. For example, for Service Pack 3,
the major version number is 3. If no Service Pack has been installed, the value is zero.

wServicePackMinor

The minor version number of the latest Service Pack installed on the system. For example, for Service Pack 3,
the minor version number is 0.

wSuiteMask

A bit mask that identifies the product suites available on the system. This member can be a combination of the following values.
Value 	Meaning

VER_SUITE_BACKOFFICE
0x00000004

Microsoft BackOffice components are installed.

VER_SUITE_BLADE
0x00000400

Windows Server 2003, Web Edition is installed.

VER_SUITE_COMPUTE_SERVER
0x00004000

Windows Server 2003, Compute Cluster Edition is installed.

VER_SUITE_DATACENTER
0x00000080

Windows Server 2008 Datacenter, Windows Server 2003, Datacenter Edition, or Windows 2000 Datacenter Server is installed.

VER_SUITE_ENTERPRISE
0x00000002

Windows Server 2008 Enterprise, Windows Server 2003, Enterprise Edition, or Windows 2000 Advanced Server is installed.
Refer to the Remarks section for more information about this bit flag.

VER_SUITE_EMBEDDEDNT
0x00000040

Windows XP Embedded is installed.

VER_SUITE_PERSONAL
0x00000200

Windows Vista Home Premium, Windows Vista Home Basic, or Windows XP Home Edition is installed.

VER_SUITE_SINGLEUSERTS
0x00000100

Remote Desktop is supported, but only one interactive session is supported.
This value is set unless the system is running in application server mode.

VER_SUITE_SMALLBUSINESS
0x00000001

Microsoft Small Business Server was once installed on the system, but may have been upgraded to another version of Windows.
Refer to the Remarks section for more information about this bit flag.

VER_SUITE_SMALLBUSINESS_RESTRICTED
0x00000020

Microsoft Small Business Server is installed with the restrictive client license in force.
Refer to the Remarks section for more information about this bit flag.

VER_SUITE_STORAGE_SERVER
0x00002000

Windows Storage Server 2003 R2 or Windows Storage Server 2003is installed.

VER_SUITE_TERMINAL
0x00000010

Terminal Services is installed. This value is always set.

If VER_SUITE_TERMINAL is set but VER_SUITE_SINGLEUSERTS is not set, the system is running in application server mode.

VER_SUITE_WH_SERVER
0x00008000

Windows Home Server is installed.

VER_SUITE_MULTIUSERTS
0x00020000

AppServer mode is enabled.

wProductType

Any additional information about the system. This member can be one of the following values.
Value 	Meaning

VER_NT_DOMAIN_CONTROLLER
0x0000002

The system is a domain controller and the operating system is Windows Server 2012 , Windows Server 2008 R2,
Windows Server 2008, Windows Server 2003, or Windows 2000 Server.

VER_NT_SERVER
0x0000003

The operating system is Windows Server 2012, Windows Server 2008 R2, Windows Server 2008, Windows Server 2003,
or Windows 2000 Server.

Note that a server that is also a domain controller is reported as VER_NT_DOMAIN_CONTROLLER, not VER_NT_SERVER.

VER_NT_WORKSTATION
0x0000001

The operating system is Windows 8, Windows 7, Windows Vista, Windows XP Professional, Windows XP Home Edition,
or Windows 2000 Professional.

wReserved

Reserved for future use.
Remarks

Relying on version information is not the best way to test for a feature. Instead, refer to the documentation
for the feature of interest. For more information on common techniques for feature detection, see Operating System Version.

If you must require a particular operating system, be sure to use it as a minimum supported version,
rather than design the test for the one operating system. This way, your detection code will continue
to work on future versions of Windows.

The following table summarizes the values returned by supported versions of Windows.
Use the information in the column labeled "Other" to distinguish between operating systems with identical version numbers.

Operating system 	Version number 	dwMajorVersion 	dwMinorVersion 	Other
Windows 10 	10.0* 	10 	0 	OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION
Windows Server 2016 	10.0* 	10 	0 	OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION
Windows 8.1 	6.3* 	6 	3 	OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION
Windows Server 2012 R2 	6.3* 	6 	3 	OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION
Windows 8 	6.2 	6 	2 	OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION
Windows Server 2012 	6.2 	6 	2 	OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION
Windows 7 	6.1 	6 	1 	OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION
Windows Server 2008 R2 	6.1 	6 	1 	OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION
Windows Server 2008 	6.0 	6 	0 	OSVERSIONINFOEX.wProductType != VER_NT_WORKSTATION
Windows Vista 	6.0 	6 	0 	OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION
Windows Server 2003 R2 	5.2 	5 	2 	GetSystemMetrics(SM_SERVERR2) != 0
Windows Home Server 	5.2 	5 	2 	OSVERSIONINFOEX.wSuiteMask & VER_SUITE_WH_SERVER
Windows Server 2003 	5.2 	5 	2 	GetSystemMetrics(SM_SERVERR2) == 0
Windows XP Professional x64 Edition 	5.2 	5 	2 	(OSVERSIONINFOEX.wProductType == VER_NT_WORKSTATION) && (SYSTEM_INFO.wProcessorArchitecture==PROCESSOR_ARCHITECTURE_AMD64)
Windows XP 	5.1 	5 	1 	Not applicable
Windows 2000 	5.0 	5 	0 	Not applicable

* For applications that have been manifested for Windows 8.1 or Windows 10. Applications not manifested for Windows 8.1 or Windows 10 will return the Windows 8 OS version value (6.2). To manifest your applications for Windows 8.1 or Windows 10, refer to Targeting your application for Windows.


You should not rely upon only the VER_SUITE_SMALLBUSINESS flag to determine whether Small Business Server
has been installed on the system, as both this flag and the VER_SUITE_SMALLBUSINESS_RESTRICTED
flag are set when this product suite is installed. If you upgrade this installation to Windows Server,
Standard Edition, the VER_SUITE_SMALLBUSINESS_RESTRICTED flag will be cleared—however, the VER_SUITE_SMALLBUSINESS
flag will remain set. In this case, this indicates that Small Business Server was once installed on this system.
If this installation is further upgraded to Windows Server, Enterprise Edition, the VER_SUITE_SMALLBUSINESS flag will remain set.

If compatibility mode is in effect, the OSVERSIONINFOEX structure contains information about the operating system
that is selected for application compatibility.

To determine whether a Win32-based application is running on WOW64, call the IsWow64Process function.
To determine whether the system is running a 64-bit version of Windows, call the GetNativeSystemInfo function.

The GetSystemMetrics function provides the following additional information about the current operating system.
Product 	Setting
Windows Server 2003 R2 	SM_SERVERR2
Windows XP Media Center Edition 	SM_MEDIACENTER
Windows XP Starter Edition 	SM_STARTER
Windows XP Tablet PC Edition 	SM_TABLETPC

Examples

For an example, see Getting the System Version.

Note

The winnt.h header defines OSVERSIONINFOEX as an alias which automatically selects the ANSI or Unicode
version of this function based on the definition of the UNICODE preprocessor constant.
Mixing usage of the encoding-neutral alias with code that not encoding-neutral can lead to mismatches
that result in compilation or runtime errors. For more information, see Conventions for Function Prototypes.
Requirements

Minimum supported client 	Windows 2000 Professional [desktop apps only]
Minimum supported server 	Windows 2000 Server [desktop apps only]
Header 	winnt.h (include Windows.h)
See also

IsWow64Process

OSVERSIONINFO
