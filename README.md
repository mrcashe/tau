# TAU Library (README)

**tau** is an open source cross-platform library for creating
graphical user interfaces (GUI) in C++ programming language

### Features

-   Pure C++ design
-   Uses C++14 standard
-   Uses exceptions for error handling
-   Uses only standard numeric types
-   Uses only standard associative containers
-   A small number of external dependencies
-   Set of widgets for GUI building
-   Internationalization support
-   Built-in font engine
-   Cross-platform file and directory management functions and classes
-   Classes and functions for UTF-8 encoding management
-   Built-in pixmap (bitmap) managing classes and functions provides import from
    BMP, ICO, ANI, XPM, CUR, Xcursor graphics formats
-   Import from PNG graphics format done with using of libpng library
-   Built-in signal/slot support for event handling (derived from libsigc++-2.0)
-   The build system is [**GNU Make**](https://www.gnu.org/software/make/).

### Host platforms

These are platforms on which the generation of target files is possible

-   Linux
-   FreeBSD

### Target platforms

These are platforms for which file generation is possible

-   Linux
-   FreeBSD
-   Windows (using M cross-platform environment, [**MXE**](https://mxe.cc)).
    MXE uses [**MinGW-w64**](https://www.mingw-w64.org) toolchain. Supported MXE
    targets at the moment are:
    +   i686-w64-mingw32.static (32 bit)
    +   x86_64-w64-mingw32.static (64 bit)
    +   i686-w64-mingw32.shared (32 bit)
    +   x86_64-w64-mingw32.shared (64 bit)

### Generating output

-   Static library for the host system (optional).
-   Shared library for the host system (default), but generation can be switched off.
-   `.pc` files for `pkg-config(1)` utility.
-   Demonstration executable binary files linked against any of generated
    shared or static library.
-   Static and shared libraries for supported MXE targets (optional).
-   C++ header files (optional).
-   [**Doxygen**](https://doxygen.nl/) documentation in HTML format (optional).

### API versioning

**tau** uses classical three-component versioning scheme: *Major_.Minor_.Micro_*.
I use underscore character ('_') here because library source code declares that
variables this manner. The actual version number can be obtained from `./VERSION` file
in project's root directory.

---

## Getting Started

This section provides information only for a quick start,
more detailed information can be found in the documentation
generated by Doxygen.

### Prerequisites
It would be a good idea to check the availability of the
necessary software tools before downloading code.
Most of that tools are part of the base system installation,
but some can be missing on your system.

#### Programs from the Unix base system
Must present if you have working system. Presence of the following
programs is mandatory or build process will fail.

- basename
- cat
- cp
- dirname
- envsubst
- find
- grep
- ln
- ls
- mkdir
- mktemp
- realpath
- rm
- sed
- tr
- uname

#### Software build tools
May not be on your system, so you may require to install additional packages.

- ar(1) (GNU binutils)
- bash(1) (GNU Bourne Again Shell)
- c++ or g++ or clang++
- gmake(1) (GNU make)
- pkg-config(1)
- strip(1) (GNU binutils)

> Note that, the build system does not support native **FreeBSD**
> `make` and `csh`, so if you are **FreeBSD** user, you may require to run:
> ~~~
> [~]$ sudo pkg install gmake bash pkgconf
> ~~~

#### Optional programs
You probably won't need these programs, but the build system will still check
for them and issue appropriate messages.

- doxygen
- latex
- ctags

#### Software packages used during build process

Note that, the following packages must have installed development files
(typically, C or C++ headers). Some Linux distros (like Ubuntu, Mageia) provide
separated packages for runtime and development files. But some others
(like ArchLinux, FreeBSD) provide monolithic packages including both runtime and
development files. In any case, the configure script will inform you if any
package is missing.

-   libc++ or libstdc++ (All platforms)

    Provided by C++ compiler, so if any of C++ compilers found, *libc++* accessible too.

-   libpng (All platforms) >= 1.6.28

    I found it already installed in my FreeBSD distro.
    Named *libpng-dev* on Ubuntu.

-   libinotify (FreeBSD only)

    I found it already installed in my FreeBSD distro.

-   On POSIX platforms:

    + libxkbcommon-x11 >= 0.5.0

        I found it already installed in my FreeBSD distro.
        Named *libxkbcommon-x11-dev* on Ubuntu.

    + libxcb >= 1.11.1

        I found it already installed in my FreeBSD distro.
        Named *libxcb1-dev* on Ubuntu.

    + libxcb-cursor >= 0.1.2

        I found it already installed in my FreeBSD distro.
        Named *libxcb-cursor-dev* on Ubuntu.

    + libxcb-icccm >= 0.4.1

        I found it already installed in my FreeBSD distro.
        Named *libxcb-icccm4-dev* on Ubuntu.

    + libxcb-renderutil >= 0.3.9

        I found it already installed in my FreeBSD distro.
        Named *libxcb-render-util0-dev* on Ubuntu.

    + libxcb-screensaver >= 1.11.1

        I found it already installed in my FreeBSD distro.
        Named *libxcb-screensaver0-dev* on Ubuntu.

    + libxcb-sync >= 1.11.1

        I found it already installed in my FreeBSD distro.
        Named *libxcb-sync-dev* on Ubuntu.

    + libxcb-xfixes >= 1.11.1

        I found it already installed in my FreeBSD distro.
        Named *libxcb-xfixes0-dev* on Ubuntu.

> Also, on Linux, the header **inotify.h** must be accessible. Since it is part
> of the **Glibc** library, there should be no problem with its availability,
> however, the installation of the Linux Kernel headers may be required.

### Download
Download can be done from the **GitHub** site.
At this moment, only source code and documentation packages are available.

#### Clone from the git repository
Therefore, **git** should be installed on your system.
Note that, the downloaded this way code is not proven and may be even unable to work.

The link is: https://github.com/mrcashe/tau.git

Choose directory where to clone remote directory and type in the console:

~~~
[~]$ git clone https://github.com/mrcashe/tau.git
~~~
The directory named `tau` will appear.

#### Download latest release
The latest release is [**0.3.0**](https://github.com/mrcashe/tau/releases/tag/0.3.0).  
Less or more stable version.  
All of the archives listed below contain the same source code, so you can use any of them.
##### Download zip archive provided by GitHub
This is automatically generated [**archive**](https://github.com/mrcashe/tau/archive/refs/tags/0.3.0.zip).
~~~
[~]$ wget https://github.com/mrcashe/tau/archive/refs/tags/0.3.0.zip
[~]$ unzip 0.3.0.zip
~~~
The directory named `tau-0.3.0` will appear.

##### Download gzip tarball provided by GitHub
This is automatically generated [**tarball**](https://github.com/mrcashe/tau/archive/refs/tags/0.3.0.tar.gz).
~~~
[~]$ wget https://github.com/mrcashe/tau/archive/refs/tags/0.3.0.tar.gz
[~]$ tar xf 0.3.0.tar.gz
~~~
The directory named `tau-0.3.0` will appear.

##### Download xz tarball created by myself
The link is: https://github.com/mrcashe/tau/releases/download/0.3.0/tau-0.3.0.tar.xz
~~~
[~]$ wget https://github.com/mrcashe/tau/releases/download/0.3.0/tau-0.3.0.tar.xz
[~]$ tar xf tau-0.3.0.tar.xz
~~~
The directory named `tau` will appear.

##### Download Doxygen documentation only
If you are not interested in building the library, you can simply download
the documentation from the [**link**](https://github.com/mrcashe/tau/releases/download/0.3.0/tau-0.3.0-doc.tar.xz).
~~~
[~]$ wget https://github.com/mrcashe/tau/releases/download/0.3.0/tau-0.3.0-doc.tar.xz
[~]$ tar xf tau-0.3.0-doc.tar.xz
~~~
The directory named `html` will appear, use `html/index.html` file as argument for WWW browser.
For addition, tau-0.3.0.pdf file will appear, use your favourite PDF viewer for reading.

### Source Tree

The typical layout of downloaded directory looks similar to:

~~~
doc/
share/
src/
sup/
AUTHORS
configure
COPYING
Makefile
README.md
VERSION
~~~

This is so-called **Source Tree**.
The most important files for you are *Makefile* and *configure*.

### Build Tree

The **Build Tree** consists of several subdirectories:

-   `conf/` is a result of configuration process and holds control data for build process.
-   `build/` where object and library files collected during build process.
-   `bin/` is a place where demonstration and test/demo binary executable files (a result of build process) will be located.

The Build Tree is fully independent of Source Tree and may be located at any place within file system.
The Source Tree doesn't modified during Configure, Build or Install processed.

## Configure

Despite the fact that the library does not use the **GNU Autotools**,
the `configure` script is provided. In contrast to *automake's* generated
scripts, this script is hand-made.

At this point, you can run `configure` script with default arguments:
~~~
[~]$ ./configure
~~~

As a result, the subdirectory named *./conf* must be created and filled within files.
Alternatively, you can run `make` (or `gmake`) without any arguments:
~~~
[~]$ gmake
~~~

`gmake` will run `configure` by itself, because subdirectory ./conf does not exists
and will start building process immediately.

You can also use configure options, the brief list is:
-   *--prefix*=PREFIX the install prefix where built files will be copied.
-   *--enable-static* enable static library building.

One more feature of `configure` script is it can be called from any place but not only
from project's root directory. Suppose, you downloaded source into ~/build/tau/ directory
and do not want to build there. You can make another directory, say ~/build/tau-build/,
`cd` to it and enter:

~~~
[~]$ ../tau/configure
~~~

...and build process will happen within `~/build/tau-build/` directory. Same way, you may
specify an absolute path to the `configure` script:

~~~
[~]$ /home/user/build/tau/configure
~~~

...and the result will be the same. This way you can build library with unlimited count of
different configurations. You even can write protect the source tree:

~~~
[~]$ chmod 0500 ~/build/tau
~~~

## Make

The standard make targets are provided:

-   **all** means usual action: to build everything that enabled;
-   **clean** also has obvious meaning: remove all built object and library files;
-   **install** install enabled components using defined install ***PREFIX***;
-   **uninstall** uninstall previously installed package using defined install ***PREFIX***.

And one more non-standard is:

-   **rm** remove entire **Build Tree** completely, the `configure` call needed to resume build process.

> The complete list of all available targets introduced in Doxygen documentation.

To build the library, run `gmake` without arguments or run `gmake all`. The build
process will start, the generated object files will be written into `./build/` subdirectory
and built binary files, including libraries, will be written into `./bin/` subdirectory.
You can use [GNU make Parallel Execution](https://www.gnu.org/software/make/manual/html_node/Parallel.html) to 
speed up build process using `-jN` or `-j N` options, where 'N' is maximal allowed job count. 
If you have 8-core CPU, the good value for N is 6, if you have only 2-core CPU, 
the better way is don't use Parallel Execution at all.

## Install

After `gmake` succeed, you may install generated files using `gmake install` command.
The default install ***PREFIX*** is `/usr/local` and you should use `sudo` or `su`
command to install files. Good alternative is specify ***$HOME*** variable as
***PREFIX*** during configure stage, but you should to setup some environment
variables in your `~/.profile`, `~/.bash_profile` or `~/.csh_profile` file,
such as ***PATH***, ***LD_LIBRARY_PATH*** and ***PKG_CONFIG_PATH***.

### What will be installed and where

-   Shared library (and static, if enabled, too) will be installed
    into ***PREFIX***/lib/ subdirectory.
-   `pkg-config` file(s) will be installed into ***PREFIX***/$(libdata)/pkgconfig/
    subdirectory, where $(libdata) is *lib* for **Linux** and *libdata* for **FreeBSD**.
-   C++ header files will be installed into ***PREFIX***/include/tau-Major_.Minor_/
    subdirectory, where *Major_* and *Minor_* are 1st and 2nd API version
    components, see above section about API versioning.
-   Binary executable files will be installed into ***PREFIX***/bin/
    subdirectory.
-   Various data files will be installed into ***PREFIX***/share/tau-Major_.Minor_/
    subdirectory, where *Major_* and *Minor_* are 1st and 2nd API version
    components, see above section about API versioning.

> Despite libtau has builtin support for [XDG Icon Themes](https://www.freedesktop.org/wiki/Specifications/icon-theme-spec/),
> SVG graphics format not yet realized in library, so I have to bundle fallback
> icon theme derived from Oxygen icon theme that consists of PNG files.
> Its name is 'Tau' and if you choose `/usr/local` or `/usr` as ***PREFIX***
> directory, that theme may be shown by other programs.

### Using without Install

If you do not planning to use built libraries, you may not install the package,
all binaries are capable to run from the `./bin/` subdirectory.
> If you didn't run `gmake install` and using separate build directory, the
> fallback icon theme will not be accessible by test applications so you will
> see the black boxes on the buttons instead of icons. To resolve this, you
> can create symbolic link to the `./share/` subdirectory within Source Tree manually:
> `ln -s /path/to/tau/share share`.

## Using Built Libraries
To use library in your applications, you should have installed `pkg-config(1)` utility.
To have access to the generated `.pc` file(s), you should install the library using
`gmake install` command. `ldconfig` invocation required when you install library into
public directory, such as `/usr/local`. The build system will try to do it for you in
case you run `gmake install` as superuser ("root") using `sudo` command or somehow else.
But in some cases the manual intervention may be required to update `ldconfig(8)` database.
Run `sudo /sbin/ldconfig` after package install if you enabled shared library building.

From the other hand, if you installed shared library somewhere withing your **$HOME** directory, the
superuser rights are not required. But you should provide proper values for
**PATH**, **LD_LIBRARY_PATH** and **PKG_CONFIG_PATH** environment variables. The most proper way
to do so, is to append:
~~~
export PATH=$HOME/bin:$PATH
export PKG_CONFIG_PATH=$HOME/lib/pkgconfig:$PKG_CONFIG_PATH	# for Linux
export PKG_CONFIG_PATH=$HOME/libdata/pkgconfig:$PKG_CONFIG_PATH	# for FreeBSD
export LD_LIBRARY_PATH=$HOME/lib:$LD_LIBRARY_PATH
~~~
lines into your `~/.profile` file and do not forget to exit your session and login again.

The `pkg-config` package name for `tau` library is **tau-Major_.Minor_**, for example,
`tau-0.3`.


### Using C++ header files
The library public API consists of series of C++ header files. Those location can be obtained
by using `--cflags` option of `pkg-config(1)` utility. This is a standard approach.

#### Compile

~~~
# Makefile
CXXFLAGS += $(shell pkg-config --cflags tau-0.3)
objects = src-1.o src-2.o

%.o: %.cc
	$(CXX) -c -o $@ $< $(CXXFLAGS)
~~~

#### Source Code
To use public API at the source code level, the simplest way is to include `tau.hh` header.
This is a recommended approach.
Here is a snippet from `./src/test/tauhello.cc` source file, the simplest program that can
use **tau** library:

~~~
/// @file tauhello.cc

#include <tau.hh>
#include <iostream>

int main(int argc, char * argv[]) {
    try {
        tau::ustring hello("Hello, world!");
        tau::Toplevel wnd(hello);
        tau::Text text(hello);
        wnd.insert(text);
        tau::Loop().run();
    }

    catch (tau::exception & x) {
        std::cerr << "** tau::exception thrown: " << x.what() << std::endl;
    }

    catch (std::exception & x) {
        std::cerr << "** std::exception thrown: " << x.what() << std::endl;
    }

    catch (...) {
        std::cerr << "** unknown exception thrown" << std::endl;
    }

    return 0;
}
~~~

### Linking against shared library
The linking process is standard:

~~~
# Makefile
LDFLAGS += $(shell pkg-config --libs tau-0.3)
objects = src-1.o src-2.o

program: $(objects)
	$(CXX) -o program $(objects) $(LDFLAGS)
~~~

### Linking against static library
For static linkage, `pkg-config` file provides variable named 'a'.

~~~
# Makefile
LDFLAGS += $(shell pkg-config --variable=a tau-0.3)
objects = src-1.o src-2.o

program: $(objects)
	$(CXX) -o program $(objects) $(LDFLAGS)
~~~
